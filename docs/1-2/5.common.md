# 고민해볼 것

### Setter는 왜 지양해야하는가?
Setter는 객체지향 원칙을 깰 위험성이 크다.

객체는 일관성을 보장받아야 하는데 도메인 규칙이 적용되는 범위 밖에서 Setter를 사용할 수 있으면 규칙과 관계 없이 정보가 변할 수 있다.

ex. 닉네임 글자수 제한을 설정해뒀는데 Setter를 만들어서 public으로 어디서든 필드에 접근이 가능하면 의도치 않은 곳에서 닉네임이 변경될 수 있다. 

단순히 입력받은 값으로 필드를 갱신하는 setter보다는 의미 있는 메서드로 상태를 변경하도록 한다. (규칙을 체크하고 맞으면 값을 갱신하도록 한다거나)

메서드 네이밍에서도 setXxxx 보다 updateXxxx처럼 구체적인 도메인 행위를 담을 수 있어야 한다.

### 기본 생성자의 접근 지정자를 제한하는 이유는?
마찬가지로 객체지향의 원칙(은닉성, 캡슐화 등)을 지키기 위함이다. **의도하지 않은** 인스턴스 생성을 막아 객체의 일관성을 유지하고, 불필요한 외부 접근을 막는다.

`public`으로 된 생성자가 의도치 않게 생성되는 경우 필수 데이터가 누락된 상태에서 불완전한 상태의 객체가 생성될 수도 있다.


기본 생성자를 protected로 제한하여 외부에서 사용하지 못하게 한다. 
JPA 내부적으로만 기본 생성자를 호출하여 안전한 엔티티 초기화를 보장할 수 있다.


### 객체 생성 시 생성자, 팩토리 메서드, 빌더 패턴 각각의 정의와 장단점


#### 생성자
생성자는 위에서 다룬 것 처럼 접근 제한을 통해 필수 값을 보장 받을 수 있다. 파라미터가 많아지면 읽기 어렵다는 문제가 있다.


#### 팩토리 메서드
정적 팩토리 메서드라고도 불리며, 생성자를 바로 사용하지 않고 생성자를 접근 제한자로 제한한 상태에서 public으로 공개된 메서드를 만들어 내부의 생성자를 사용하는 방식으로 객체를 생성하도록 하는 메서드이다. 

생성자는 이름이 고정이지만 팩토리 메서드는 이름을 자유롭게 부여하여 의도를 표현하기 좋다. 
ex. `Member.of(name)`

하지만 마찬가지로 메서드 파라미터를 받아 이루어지므로 파라미터가 많아지면 가독성이 문제

#### 빌더
**필수 값과 선택 값을 구분**하고 메서드 체이닝을 통해 객체를 단게적으로 생성하는 방식이다.


체이닝 메서드를 사용하기 때문에 사용되는 필드가 많아도 가독성이 좋다.

다만 가독성은 해결되어도 코드 자체는 다소 길어질 수 있고 빌더 클래스를 추가로 생성해야해서 오버헤드가 발생할 수 있다.



### Lombok
> Lombok이란 어노테이션 기반으로 코드를 자동완성 해주는 라이브러리이다.

`@Getter`, `@Setter`, `@Builder`, `@RequiredArgsConstructor`, `@Sl4fj` 등 다양한 애노테이션이 있으며 이를 활용하여
Getter/Setter, 생성자, equals/hashCode, toString, Builder, 로거 필드 등을 자동 생성하여 코드량을 줄일 수 있다.

주로 다음과 같은 방식으로 코드 중복을 줄일 수 있다.
- `@RequiredArgsConstructor`로 final 필드 생성자를 자동 생성하여 의존성을 주입
- DTO에는 @Builder, 엔티티엔 `@NoArgsConstructor(access = PROTECTED)`를 설정
  - `@Getter`를 쓰면 getter를 자동 생성할 수 있고, `NoArgsConstructor`를 쓰면 JPA 프록시/리플렉션을 위한 기본 생성자를 보장

>JPA에서
> - 프록시 : Hibernate가 지연 로딩을 위해 엔티티의 가짜 객체를 만들어두고, 실제 데이터 접근 시점에 DB에서 로딩하는 기법
> - 리플렉션 : 프레임워크가 코드를 런타임에 들여다보고 개발자가 직접 new를 호출하지 않아도 인스턴스를 만드는 기법. JPA 구현체(Hibernate 등)는 리플렉션으로 엔티티 객체를 생성한다.


access를 PROTECTED로 설정하는 이유는 public으로 만들어지면 빈 객체를 생성하는 등 불완전한 상태로 엔티티가 생길 가능성이 있기 때문이며, 이로 인해 필수 값에 대해 검증하거나 하는 생성 로직을 우회하게 된다.

protected로 하게되면 프록시 등에서 super()를 호출할 수 있기 때문에 protected로 설정하는 것이 JPA 스펙을 충족한다.


### 지연 로딩

JPA에서 FetchType.LAZY 설정은 지연로딩을 의미한다. 

지연로딩은 연관 엔티티나 컬렉션을 바로 가져오지 않고 프록시나 지연 컬렉션에 두고, 해당 필드에 처음 접근하는 시점에 추가 쿼리를 실행하여 로딩하는 방식이다.

연관되어있는 데이터를 항상 모두 가져오면 불필요한 데이터를 가져오는 경우도 있기 때문에, 실제로 필요한 때만 필요한 데이터만 로딩해서 성능과 메모리를 아끼기 위해 설정한다.

주의할점으로는 트랜잭션 밖에서 프록시에 접근하면 Exception이 일어날 수 있으며, 반복 접근시 N+1문제가 생길 수 있어서 fetch join이나 batch fetch등이 필요하다.

> N+1문제는 한번 조회할 때 N개의 엔티티를 가져오고, 각 엔티티의 연관 데이터를 Lazy로 접근할 때마다 추가 쿼리가 N번 더 실행되어 총 쿼리가 1+N이 되는 문제

